/////////////////////////////////////////////////////////////////////////////////
/// \addtogroup led_control_module
/// \{
/// \author Dev
///
///	\brief 
///
///
/// \file
/// \brief Fichier source du module led_control_module
///
///
///
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Includes
/////////////////////////////////////////////////////////////////////////////////
#include <stdint.h>
#include <stdbool.h>

#include <ti/sysbios/hal/Timer.h>

#include "inc/hw_ints.h"

#include "system.h"

#include "serial_link.h"
#include "serial_link_frame_protocol.h"
#include "common.h"
#include "exchange.h"
#include "led_control_module.h"

/////////////////////////////////////////////////////////////////////////////////
// Private define
/////////////////////////////////////////////////////////////////////////////////
#define MAX_NB_MSG	4

/////////////////////////////////////////////////////////////////////////////////
// Private macro
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Private typedef
/////////////////////////////////////////////////////////////////////////////////
typedef struct
{
	bool isUsed;
	tExchangeMsg msg;
}tbuffMsg;

/////////////////////////////////////////////////////////////////////////////////
// Private variables
/////////////////////////////////////////////////////////////////////////////////

static tbuffMsg m_arrMsg[MAX_NB_MSG];

/////////////////////////////////////////////////////////////////////////////////
// Exported variables
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Private function prototypes
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Functions
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \param
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
bool LED_CONTROL_Init(void)
{

	//Init the buffer array
	for (int i = 0; i < MAX_NB_MSG; ++i)
	{
		m_arrMsg[i].isUsed = false;
	}

	m_channelNumber = SerialLinkFrameProtocoleInit(SERIAL1,
												   B115200,
												   BIT_8,
												   PARITY_NONE,
												   STOP_BIT_1,
												   Reception_complete,
												   &m_channelNumber,
												   Alloc,
												   Free
												   );



	return true;
}

/////////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \param
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
bool LED_CONTROL_RgbSend(tRGBControl* control)
{

	return true;
}

void LED_CONTROL_Test(uint16_t data)
{
}


/////////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \param
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
static uint8_t* AllocMsg(void)
{
	uint8_t i;

	for (i = 0; i < NB_MAX_MSG; ++i)
	{
		if(m_arrMsg[i].isUsed == false)
		{
			m_arrMsg[i].isUsed = true;
			return m_arrMsg[i].msg;
		}

	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \param
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
static void FreeMsg(void *pMsg)
{
	uint8_t i;

	for (i = 0; i < NB_MAX_MSG; ++i)
	{
		if(m_arrMsg[i].msg == pMsg)
		{
			m_arrMsg[i].isUsed = false;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \param
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
static void process_data(void* pData, uint8_t *pMsg, uint16_t size)
{

	status = UARTIntStatus(UART7_BASE, true);
	car = (uint8_t)UARTCharGetNonBlocking(UART7_BASE);
	UARTIntClear(UART7_BASE, status);
	Hwi_clearInterrupt(INT_UART7_TM4C129);
	nbInt++;
}

///
/// \}
///
