/////////////////////////////////////////////////////////////////////////////////
/// \addtogroup led_control_module
/// \{
/// \author Dev
///
///	\brief 
///
///
/// \file
/// \brief Fichier source du module led_control_module
///
///
///
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Includes
/////////////////////////////////////////////////////////////////////////////////
#include <stdint.h>
#include <stdbool.h>

#include <ti/sysbios/hal/Timer.h>

#include "inc/hw_ints.h"

#include "system.h"

#include "serial_link.h"
#include "serial_link_frame_protocol.h"
#include "common.h"
#include "exchange.h"
#include "led_control_module.h"

/////////////////////////////////////////////////////////////////////////////////
// Private define
/////////////////////////////////////////////////////////////////////////////////
#define MAX_NB_MSG	4

/////////////////////////////////////////////////////////////////////////////////
// Private macro
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Private typedef
/////////////////////////////////////////////////////////////////////////////////
typedef struct
{
	bool isUsed;
	tExchangeMsg msg;
}tbuffMsg;

/////////////////////////////////////////////////////////////////////////////////
// Private variables
/////////////////////////////////////////////////////////////////////////////////
static uint8_t m_channelNumber = NULL;
static tbuffMsg m_arrMsg[MAX_NB_MSG];

static tRGBControl m_RGBStatus = {0, 0, 0, 0};
static uint16_t m_cptErr;
/////////////////////////////////////////////////////////////////////////////////
// Exported variables
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Private function prototypes
/////////////////////////////////////////////////////////////////////////////////
static uint8_t* AllocMsg(void);
static void FreeMsg(void *pMsg);
static void process_data(void* pData, uint8_t *pMsg, uint16_t size);

/////////////////////////////////////////////////////////////////////////////////
// Functions
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \param
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
bool LED_CONTROL_Init(void)
{

	uint8_t i;
	//Init the buffer array
	for (i = 0; i < MAX_NB_MSG; ++i)
	{
		m_arrMsg[i].isUsed = false;
	}

	m_channelNumber = SerialLinkFrameProtocoleInit(SERIAL1,
												   B115200,
												   BIT_8,
												   PARITY_NONE,
												   STOP_BIT_1,
												   process_data,
												   &m_channelNumber,
												   AllocMsg,
												   FreeMsg
												   );


	return true;
}

/////////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \param
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
bool LED_CONTROL_RgbSend(tRGBControl* control)
{
	tExchangeMsg* pMsg;

	pMsg = (tExchangeMsg*)AllocMsg();

	pMsg->header.commandID = COMMAND_SET_RGB_CONTROL;
	pMsg->header.datasize = sizeof(tRGBControl);
	memcpy(pMsg->req.data, control, sizeof(tRGBControl));

	SerialLinkFrameProtocole_Send(m_channelNumber, (uint8_t*)pMsg, (sizeof(tExchangeHeader) + sizeof(tRGBControl)));
	return true;
}

void LED_CONTROL_Test(uint16_t data)
{
}


/////////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \param
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
static uint8_t* AllocMsg(void)
{
	uint8_t i;

	for (i = 0; i < MAX_NB_MSG; ++i)
	{
		if(m_arrMsg[i].isUsed == false)
		{
			m_arrMsg[i].isUsed = true;
			return (uint8_t*)&(m_arrMsg[i].msg);
		}

	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \param
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
static void FreeMsg(void *pMsg)
{
	uint8_t i;

	for (i = 0; i < MAX_NB_MSG; ++i)
	{
		if(&m_arrMsg[i].msg == pMsg)
		{
			m_arrMsg[i].isUsed = false;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \param
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
static void process_data(void* pData, uint8_t *pMsg, uint16_t size)
{
	tExchangeMsg* message = (tExchangeMsg*)pMsg;

	switch (message->header.commandID)
	{
		case COMMAND_SET_RGB_CONTROL:
			if(message->ans.status != STATUS_OK)
			{
				m_cptErr++;
			}
			break;
		case COMMAND_GET_RGB_CONTROL:
			if(message->header.datasize == sizeof(tRGBControl))
			{
				memcpy(&m_RGBStatus, message->ans.data, sizeof(tRGBControl));
			}
			break;
		case COMMAND_GET_STATUS:
			if(message->header.datasize == sizeof(tSlaveStatus))
			{

			}

			break;
		case COMMAND_GET_DATE_TIME:
			if(message->header.datasize == sizeof(tDateTime))
			{

			}
			break;
		case COMMAND_UPDATE_DATE_TIME:

			break;
		default:
			break;
	}

}

///
/// \}
///
