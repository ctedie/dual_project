/////////////////////////////////////////////////////////////////////////////////
/// \addtogroup user_flash_lib
/// \{
/// \author Dev
///
///	\brief 
///
///
/// \file
/// \brief Fichier source du module user_flash_lib
///
///
///
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Includes
/////////////////////////////////////////////////////////////////////////////////
#include <stdint.h>

#include "inc/hw_types.h"

#include "driverlib/flash.h"

#include "user_flash_lib.h"

/////////////////////////////////////////////////////////////////////////////////
// Private typedef
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Private define
/////////////////////////////////////////////////////////////////////////////////
#define USER_FLASH_SIZE				0x10000
#define USER_FLASH_START_ADDRESS	0x30000
#define USER_FLASH_MIN_WRITE_SIZE	4

#define USER_FLASH_BLOCK_SIZE		0x400

/////////////////////////////////////////////////////////////////////////////////
// Private macro
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Private variables
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Exported variables
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// Private function prototypes
/////////////////////////////////////////////////////////////////////////////////
static tBoolean CheckAddress(uint32_t ulAddress);

/////////////////////////////////////////////////////////////////////////////////
// Functions
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \param
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
void UserFlashInit(void)
{

}

/////////////////////////////////////////////////////////////////////////////////
/// \brief Write data in the user flash
///
/// \param pulData 		A pointer to a variable containing the data to write
/// \param ulAddress 	The address to write data
/// \param ulCount		The number of <em>long word (4 bytes)<\em> to write.
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
int32_t UserFlashWrite(const uint32_t *pulData, uint32_t ulAddress, uint32_t ulCount)
{
	uint32_t err;

	err = FlashProgram(	(unsigned long*)pulData,
						(unsigned long)(ulAddress + USER_FLASH_START_ADDRESS),
						(unsigned long)(ulCount * USER_FLASH_MIN_WRITE_SIZE));

	return err;
}

/////////////////////////////////////////////////////////////////////////////////
/// \brief Read data in the user flash
///
/// \param pulData 		A pointer to a variable to store the read data
/// \param ulAddress 	The address to read data
/// \param ulCount		The number of <em>long word (4 bytes)<\em> to read
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
int32_t UserFlashRead(uint32_t *pulData, uint32_t ulAddress, uint32_t ulCount)
{
	uint32_t index;
	uint32_t userFlashAddress;
	uint32_t *tmpData;

	userFlashAddress = ulAddress + USER_FLASH_START_ADDRESS;

	if(CheckAddress(ulAddress) == false)
	{
		return -1;
	}

	tmpData = userFlashAddress;

	for (index = 0; index < (ulCount * USER_FLASH_MIN_WRITE_SIZE); index+=USER_FLASH_MIN_WRITE_SIZE)
	{
		*(pulData + index) = *(tmpData + index);
	}
	return 0;
}

/////////////////////////////////////////////////////////////////////////////////
/// \brief Erase a block of memory. This function is blocking
///
/// \param ulAddress 	The address of the erase start
/// \param ulSize 		The number of block to erase. <em>1 Block = 1024 Bytes</em>
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
int32_t UserFlashErase(uint32_t ulAddress, uint32_t ulSize)
{
	uint8_t index;
	uint32_t userFlashAddress;

	if(CheckAddress(ulAddress) == false)
	{
		return -1;
	}

	if(ulSize>64)
	{
		return -1;
	}

	userFlashAddress = ulAddress + USER_FLASH_START_ADDRESS;

	for (index = 0; index < ulSize; ++index)
	{
		FlashErase((unsigned long int)(userFlashAddress+index));
	}

	return 0;
}

/////////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \param
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
uint32_t UserFlashGetSize(void)
{
	return USER_FLASH_SIZE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \param
///
/// \return
///
/////////////////////////////////////////////////////////////////////////////////
uint32_t UserFlashGetBlockSize(void)
{
	return USER_FLASH_BLOCK_SIZE;
}


/////////////////////////////////////////////////////////////////////////////////
/// \brief Check if the address is within the UserFlash memory bound
///
/// \param ulAddress The Address to check
///
/// \return A boolean
/// \retval TRUE The address is ok
/// \retval FALSE The address is out of bound
///
/////////////////////////////////////////////////////////////////////////////////
static tBoolean CheckAddress(uint32_t ulAddress)
{
	if(ulAddress > (USER_FLASH_SIZE-4))
	{
		return false;
	}
	else
	{
		return true;
	}
}


///
/// \}
///
